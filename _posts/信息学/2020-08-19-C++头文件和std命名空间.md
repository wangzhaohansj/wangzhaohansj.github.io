---
title: "[转载]C++头文件和命名空间"
date: 2020-8-19
tags: "信息学"
category: "信息学"
excerpt: "如果侵犯您，请发送邮件至mixuanda@outlook.com"
comments: true
comments: true
---
# C++头文件以及命名空间的发展历程
+ C++ 是在C语言的基础上开发的，早期的 C++ 还不完善，不支持命名空间，没有自己的编译器，而是将 C++ 代码翻译成C代码，再通过C编译器完成编译。
+ 这个时候的 C++ 仍然在使用C语言的库，```stdio.h```、```stdlib.h```、```string.h``` 等头文件依然有效
+ 此外 C++ 也开发了一些新的库，增加了自己的头文件，例如：
  - ```iostream.h```：用于控制台输入输出头文件。
  - ```fstream.h```：用于文件操作的头文件。
  - ``` complex.h```：用于复数计算的头文件。

+ 和C语言一样，C++ 头文件仍然以.h为后缀，它们所包含的类、函数、宏等都是全局范围的。

+ 后来 C++ 引入了命名空间的概念，计划重新编写库
+ 将类、函数、宏等都统一纳入一个命名空间
+ 这个命名空间的名字就是std。std 是 standard 的缩写，意思是“标准命名空间”。

+ 但是这时已经有很多用老式 C++ 开发的程序了，它们的代码中并没有使用命名空间
+ 直接修改原来的库会带来一个很严重的后果
+ 程序员会因为不愿花费大量时间修改老式代码而极力反抗，拒绝使用新标准的 C++ 代码。
+ C++ 开发人员想了一个好办法，保留原来的库和头文件，它们在 C++ 中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改
+ 把类、函数、宏等纳入命名空间 std 下，就成了新版 C++ 标准库。
+ 这样共存在了两份功能相似的库，使用了老式 C++ 的程序可以继续使用原来的库，新开发的程序可以使用新版的 C++ 库。

+ 为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整 :
  - 去掉了后缀.h，所以老式 C++ 的```iostream.h```变成了`iostream`，```fstream.h```变成了```fstream```
  - 而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c字母
  - 所以C语言的```stdio.h```变成了```cstdio```，```stdlib.h```变成了```cstdlib```。

+ ***需要注意的是，旧的 C++ 头文件是官方所反对使用的，已明确提出不再支持，但旧的C头文件仍然可以使用，以保持对C的兼容性。***
+ 实际上，编译器开发商不会停止对客户现有软件提供支持，可以预计，旧的 C++ 头文件在未来数年内还是会被支持。

# 命名空间
## 为什么会有命名空间
一个中大型软件往往由多名程序员共同开发，会使用大量的变量和函数，不可避免地会出现变量或函数的命名冲突。当所有人的代码都测试通过，没有问题时，将它们结合到一起就有可能会出现命名冲突。

例如小李和小韩都参与了一个文件管理系统的开发，它们都定义了一个全局变量 fp，用来指明当前打开的文件，将他们的代码整合在一起编译时，很明显编译器会提示 fp 重复定义（Redefinition）错误。

## 如何解决

* 为了解决合作开发时的命名冲突问题，C++ 引入了命名空间（Namespace）的概念。请看下面的例子：
```c++
namespace Li{  //小李的变量定义
    FILE fp = NULL;
}
namespace Han{  //小韩的变量定义
    FILE fp = NULL
}
```
* 小李与小韩各自定义了以自己姓氏为名的命名空间，此时再将他们的 fp 变量放在一起编译就不会有任何问题。
* 命名空间有时也被称为名字空间、名称空间。```namespace ```
是C++中的关键字，用来定义一个命名空间，语法格式为：
``` c++
namespace name{
    //variables, functions, classes
}
```
* 其中,name是命名空间的名字，它里面可以包含变量、函数、类、```typedef```、```#define``` 等，最后由{ }包围。

* 使用变量、函数时要指明它们所在的命名空间。以上面的 fp 变量为例，可以这样来使用：
``` c++
Li::fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```
* 请注意, ``::``是一个新符号，称为**域解析操作符**，在C++中用来**指明要使用的命名空间**。

---
* 除了直接使用域解析操作符，还可以采用`` using`` 关键字声明，例如：
``` c++
using Li::fp;
fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han :: fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```
* 在代码的开头用``using``声明了 `Li::fp`，它的意思是，`using` 声明以后的程序中如果出现了**未指明命名空间**的`` fp``，就使用 ``Li::fp``；但是若要使用**其他人**定义的 ``fp``，仍然需要 ``Han::fp``。

* `using` 声明不仅可以针对**命名空间中的一个变量**，也可以用于声明**整个命名空间**，例如：
``` c++
using namespace Li;
fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```
* 如果命名空间 `Li` 中还定义了**其他**的变量，那么同样具有 `fp` 变量的效果。在 ``using`` 声明后，如果有**未具体指定命名空间的变量**产生了**命名冲突**，那么**默认采用**命名空间`` Li`` 中的变量。

* 命名空间内部不仅可以**声明或定义变量**，对于其它**能在命名空间以外声明或定义的名称**，同样也都能在**命名空间内部进行声明或定义**，例如类、函数、`typedef`、``#define`` 等都可以出现在命名空间中。

站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，例如 `typedef` 定义的类型别名。

下面来看一个命名空间完整示例代码：
``` c++
#include <iostream>
//将类定义在命名空间中
namespace Diy{
    class Student{
    public:
        char *name;
        int age;
        float score;

    public:
        void say(){
            cout << name << "的年龄是" << age<<"，成绩是 "<< score<<endl;
        }
    };
}
int main(){
    Diy::Student stu1;
    stu1.name = "小明";
    stu1.age = 15;
    stu1.score = 92.5;
    stu1.say();
    return 0;
}
```
运行结果：
小明的年龄是 15，成绩是 92.5

# C++ 头文件的现状
1. 旧的 C++ 头文件，如 iostream.h、fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。

2. 新的 C++ 头文件，如 iostream、fstream 等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间 std 中。
  1. 注意：在标准化的过程中，库中有些部分的细节被修改了，所以**旧的头文件和新的头文件不一定完全对应**
3. 标准C头文件如 stdio.h、stdlib.h 等继续被支持。头文件的内容不在 std 中。

4. 具有C库功能的新C++头文件具有如 cstdio、cstdlib 这样的名字。它们*提供的内容*和*相应的旧的C头文件* **相同**，只是**内容在 std 中**。

5. 可以发现，对于*不带.h的头文件*，**所有的符号** 都位于命名空间 std 中，使用时需要**声明命名空间 std**；对*于带.h的头文件*，**没有使用任何命名空间，所有符号都位于全局作用域**。这也是 C++ 标准所规定的。

6. 不过现实情况和 C++ 标准所期望的有些不同，对于*原来C语言的头文件*，即使**按照 C++ 的方式来使用**，即#include <cstdio>这种形式，那么符号**可以位于命名空间 std 中，也可以位于全局范围中**，请看下面的两段代码。
    1. 使用命名空间 std：
``` c++
#include <cstdio>
int main(){
    std::printf("Hello World!\n");
    return 0;
}
```
    2. 不使用命名空间 std：
```c++
#include <cstdio>
int main(){
    printf("Hello World!\n");
    return 0;
}
```
* 这两种形式在 Microsoft Visual C++ 和 GCC 下都能够***编译通过***，也就是说，大部分编译器在实现时并没有**严格遵循**C++标准，它们对两种写法都**支持**，程序员**可以使用 std 也可以不使用**。

* 第一种写法是标准的，但是第二种不标准，虽然它们在目前的编译器中都**没有错误**，但我依然推荐使用第1种写法，因为标准写法会一直被编译器支持，非标准写法可能会在以后的升级版本中不再支持。

# 使用C++的头文件

* ***虽然 C++ 几乎完全兼容C语言，C语言的头文件在 C++ 中依然被支持，但 C++ 新增的库更加强大和灵活，请读者尽量使用这些 C++ 新增的头文件，例如 iostream、fstream、string 等。***

* 我不推荐将C代码和 C++ 代码混合在了一起，因此请尽量使用 C++ 的方式。下面的例子演示了如何使用 C++ 库进行输入输出：
```c++
#include <iostream>
#include <string>
int main(){
    //声明命名空间std
    using namespace std;
    //定义字符串变量
    string str;
    //定义 int 变量
    int age;
    //从控制台获取用户输入
    cin>>str>>age;
    //将数据输出到控制台
    cout<<str<<"-"<<age<<endl;
    return 0;
}
```
* 在看这段代码的时候,只需要留意 **using namespace std;**，它声明了命名空间 std，后续如果有未指定命名空间的符号，那么默认使用 std，代码中的 string、cin、cout 都位于命名空间 std。

* 在 **main() 函数** 中声明命名空间 std，它的作用范围就位于    **main() 函数内部**，如果在其他函数中又用到了 std，就需要重新声明，请看下面的例子：
```c++
#include <iostream>
void func(){
    //必须重新声明
    using namespace std;
    cout<<"Hello World!"<<endl;
}
int main(){
    //声明命名空间std
    using namespace std;
    cout<<"Hello World!"<<endl;
    func();
    return 0;
}
```
* 如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中，例如：
```c++
#include <iostream>
//声明命名空间std
using namespace std;
void func(){
    cout<<"Hello World!"<<endl;
}
int main(){
    cout<<"Hello World!"<<endl;
    func();
    return 0;
}
```

---

* 声明
如果侵犯您，请发送邮件至mixuanda@outlook.com
